#include <stdio.h>
#include <stdlib.h>

short int memo[134217728];// Δημιουργώ τον πίνακα memo που θα μου επιτρέψει να εφαρμόσω δυναμικό προγραμματισμό
                          //ορίζω ως τύπο τον short int αντί για int προκειμένου να δεσμεύω λιγότερη μνήμη, ειδικά σε έναν τόσο μεγάλο πίνακα
                          //Το μέγεθος του ορίζεται αυτό γιατί έπειτα από έρευνα είδα ότι η δημιοργία πινάκων είναι γρηγορότερη όταν το πλήθος
                          //των κελιών είναι δύναμη του 2. Στο συγκεκριμένο πρόγραμμα μπορούμε να χρησιμοποιήσουμε μέχρι και την θέση 100.000.000


int main(int argc, char **argv) // ορίζω τα ορίσματα της main προκειμένου να λαμβάνω input από το command line
{
    int upper_bound, lower_bound,max=-1,count,i; //δηλώσεις μεταβλητών
    long long num;// δήλωση μεταβλητής num σε long long int για να αποφύγουμε υπερχείληση του αριθμού 
    memo[1]=1; // αρχικοποίηση του πρώτου κελιού του array - ουσιαστικά είναι το base case πάνω στο οποίο "οικοδομούνται" τα επόμενα κελιά του πίνακα
    if (argc != 3) // έλεγχος πλήθους παραμέτρων
    {
           return 1;
    }
    lower_bound=atoi(argv[1]);// αποθήκευση παραμέτρων από γραμμή εντολών σε μεταβλητές
    upper_bound=atoi(argv[2]);
    if(lower_bound<1 || upper_bound<1 || upper_bound >100000000 || lower_bound>=upper_bound) // έλεγχος των ορίων σε περίπτωση που έχω μη θετικά δεδομένα
    {
      max=0; //ορίζεται ως αποτέλεσμα το μηδέν και δεν τρέχει καν το υπόλοιπο τμήμα του αλγορίθμου
    }
    else // περίπτωση που δίνονται αποδεκτά όρια upper_bound και lower_bound
    {
        for(i=2; i<=upper_bound; i++)// έναρξη βασικού βρόχου for για της ακολουθίας Collatz για κάθε αριθμό από το 2 μέχρι και το upper_bound
        {
           count=0; // σε κάθε καινούρια επανάληψη το πλήθος των βημάτων Collatz του εκάστοτε αριθμού ορίζεται το 0
           num=i; //καταχωρούμε στην μεταβλητή num το i, δηλαδή τον αριθμό που εξετάζουμε προκειμένου να μην επηρεάσουμε την μεταβλητή i 
           while(1) // έναρξη βρόχου while για τον υπολογισμό βημάτων, σταματάει αν και μόνον αν συναντήσουμε εντολή break;
           {
              if(num & 1)// περίπτωση όπου το num είναι περιττός αριθμός
              {
                 num=(3*num+1); // ανανέωση τιμής του num με 3*num+1
                 num>>=1; // ανανέωση τιμής του num με num/2 (για περισσότερη επεξήγηση παρακαλώ ανατρέξτε στο README.md)
                 count=count +2; // προσαύξηση του μετρητή κατά 2, λόγω παράλειψης βήματος
              }
              else // περίπτωση else - δηλαδή περίπτωση όπου το num είναι άρτιο
              {
                 num>>=1; //ανανέωση της τιμής του num με num/2
                 if(num<i) //έλεγχος για την ύπαρξη του num σε αποδεκτό εύρος για την αξιοποίηση του πίνακα memo για τον δυναμικό προγραμματισμό
                 {
                     count=count+memo[num]+1; // ανανέωση τιμής counter - προσαύξηση κατά 1 λόγο προηγούμενης εντολής και προσαύξηση κατά memo[num] λόγω αξιοποίησης βημάτων προηγούμενου αριθμού
                     break;// εντολή break για την έξοδο μας από τον βρόχο του while μιας και η συνθήκη είναι πάντοτε αληθής
                 }
                 count++;// προσαύξηση για μια τελευταία φορά του count κατά 1
              } 
           }
           memo[i]=count; //αποθήκευση του αριθμού βημάτων προς το 1 του αριθμού i στην θέση i του πίνακα memo
       }
       for(i=lower_bound; i<=upper_bound; i++) // έναρξη επαναληπτικού βρόχου for για την εύρεση του μέγιστου path ανάμεσα στο lower_bound και το upper_bound
       {
          if(max<memo[i]) // συνθήκη που ελέγχει εάν τα βήματα προς το 1 του αριθμού 1 είναι περισσότερα από την μέχρι πρότινως μεγαλύτερη
          {               // ακολουθία Collatz
            max=memo[i];  // σε περίπτωση που η παραπάνω συνθήκη είναι πράγματι αληθής ανανεώνεται η μεταβλητή max με το memo[i]
          }
       }
    }
    printf("%d\n",max); // εκτύπωση τελικής απάντησης
    return 0;
}